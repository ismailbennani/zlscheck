open FadFloat
open Discrete_obs_fad

(* AT1:  □_[0.0, 20.0] (speed < 120.0) *)
node at1 (tstep, outp) =
    let speed = Array.get outp 2 in
    always_timed 20. (tstep, q_lt (speed, make 120.))

(* AT2:  □_[0.0, 10.0] (RPM < 4750.0) *)
node at2 (tstep, outp) =
    let rpm = Array.get outp 0 in
    always_timed 10. (tstep, q_lt (rpm, make 4750.))

(* AT5*: □_[0.0, 30.0] ((!(gear == * ) && ◇_[0.001, 0.1] (gear == * )) ==> ◇_[0.001, 0.1] □_[0.0, 2.5] (gear == * )) *)
node at5 geari (tstep, outp) =
    let gear = Array.get outp 1 in
    let start = q_true fby q_false in
    let switch = q_and(q_not start, q_up (q_eqi (gear, make geari))) in
    always_timed 30.
        (tstep,
            alwaysBfromA_timed 2.5 (tstep, switch, q_eqi(gear, make geari)))

node at51 (tstep, outp) = at5 1. (tstep, outp)
node at52 (tstep, outp) = at5 2. (tstep, outp)
node at53 (tstep, outp) = at5 3. (tstep, outp)
node at54 (tstep, outp) = at5 4. (tstep, outp)

(* AT6(t,s): (□_[0.0, 30.0] (RPM < 3000.0) ==> □_[0.0, t] (speed < s)) *)

node at6 tstep (t, s) (outp) =
    let rpm = Array.get outp 0 in
    let speed = Array.get outp 2 in
    let rpm_max = make 3000. in
    let speed_max = make s in
    q_or (once_timed 30. (tstep, q_gt (rpm, rpm_max)),
          always_timed t (tstep, q_lt (speed, speed_max)))

(* AT6(t,s): (□_[0.0, 30.0] (RPM < 3000.0) ==> □_[0.0, t] (speed < s)) *)
node at6a (tstep, outp) =
    let rpm = Array.get outp 0 in
    let speed = Array.get outp 2 in
    let rpm_max = make (3000.) in
    let speed_max = make (35.) in
    q_or (once_timed 30. (tstep, q_gt (rpm, rpm_max)),
          always_timed 3.99 (tstep, q_lt (speed, speed_max)))
node at6b (tstep, outp) =
    let rpm = Array.get outp 0 / (make 5000.) in
    let speed = Array.get outp 2 / (make 120.) in
    let rpm_max = make (3000. /. 5000.) in
    let speed_max = make (50. /. 120.) in
    q_or (once_timed 30. (tstep, q_gt (rpm, rpm_max)),
          always_timed 7.99 (tstep, q_lt (speed, speed_max)))
node at6c (tstep, outp) =
    let rpm = Array.get outp 0 / (make 5000.) in
    let speed = Array.get outp 2 / (make 120.) in
    let rpm_max = make (3000. /. 5000.) in
    let speed_max = make (65. /. 120.) in
    q_or (once_timed 30. (tstep, q_gt (rpm, rpm_max)),
          always_timed 19.99 (tstep, q_lt (speed, speed_max)))



node autotrans_at1 tstep inp = next_t, outp, rob where
    rec throttle = Array.get inp 0
    and brake = Array.get inp 1
    and init tstep' = make tstep
    and next_t = t +. tstep
    and (t, rpm, gear, speed, up_th, dn_th), _ = Autotransc.autotransd 100. tstep (throttle, brake)
    and outp = Array.of_list [rpm; gear; speed; up_th; dn_th]
    and rob = at1 (tstep', outp)

(* hybrid aux u = Array.of_list [y] where
    rec u1 = Array.get u 0
    and u2 = Array.get u 1
    and dy = if switched then u2 else u1 
    and der y_ = Fad_hacks.get dy init Fad_hacks.get (zero ())
    and y = Fad_hacks.make y_
    and switched = present (init) | (period(1.)) -> false fby true init false

node aux_d tstep u = t, y where
    rec u1 = Array.get u 0
    and u2 = Array.get u 1 
    and dy = if switched then u2 else u1
    and y = zero () -> (pre y) + scale dy tstep
    and t = 0. fby (t +. tstep)
    and switched = t >= 1.

open Nodes_fad
node autotrans_at1 tstep inp = t, outp, rob where
    rec 
    let init u1 = 
        let u = FadFloat.make 1. in
        FadFloat.diff u 0 2;
        u
    and init u2 = 
        let u = FadFloat.make 2. in
        FadFloat.diff u 1 2;
        u
    in do
        { time = t; status = _; result = result } = 
            Nodes_fad.solve aux 20. (next_horizon, Array.of_list [ u1; u2 ])
        (* and _ = print_endline ("t=" ^ (string_of_float t) ^ "; rob=" ^ (string_of_float rob))) *)
        and next_horizon =
        tstep fby (if t >= next_horizon then next_horizon +. tstep else next_horizon)
        and rob = Array.get result 0
        
        (* and t, rob = aux_d tstep (Array.of_list [u1; u2 ]) *)

        and outp = Array.of_list []
    done *)



node autotrans_at2 tstep inp = next_t, outp, translate rob 40. where
    rec throttle = Array.get inp 0
    and brake = Array.get inp 1
    and init tstep' = make tstep
    and next_t = t +. tstep
    and (t, rpm, gear, speed, up_th, dn_th), _ = Autotransc.autotransd 100. tstep (throttle, brake)
    and outp = Array.of_list [rpm; gear; speed; up_th; dn_th]
    and rob = at2 (tstep', outp)

node autotrans_at51 tstep inp = next_t, outp, rob where
    rec throttle = Array.get inp 0
    and brake = Array.get inp 1
    and init tstep' = make tstep
    and next_t = t +. tstep
    and (t, rpm, gear, speed, up_th, dn_th), rob_optim = Autotransc.autotransd 100. tstep (throttle, brake)
    and outp = Array.of_list [rpm; gear; speed; up_th; dn_th]
    and rob_spec = at51 (tstep', outp)
    and _ = print_endline "autotrans_at51"
    and rob = if isFalse rob_spec then rob_spec else if isTrue rob_optim then rob_optim else rob_spec

(* had an issue where sometimes a counter example with rob -9e-15 appears
   and it is rejected by validation, so I add 0.1 to discard these *)
node autotrans_at52 tstep inp = next_t, outp, rob + (make 0.1) where
    rec throttle = Array.get inp 0
    and brake = Array.get inp 1
    and init tstep' = make tstep
    and next_t = t +. tstep
    and (t, rpm, gear, speed, up_th, dn_th), rob_optim = Autotransc.autotransd 100. tstep (throttle, brake)
    and outp = Array.of_list [rpm; gear; speed; up_th; dn_th]
    and rob_spec = at52 (tstep', outp)
    and rob = if isFalse rob_spec then rob_spec else if isTrue rob_optim then rob_optim else rob_spec

node autotrans_at53 tstep inp = next_t, outp, rob where
    rec throttle = Array.get inp 0
    and brake = Array.get inp 1
    and init tstep' = make tstep
    and next_t = t +. tstep
    and (t, rpm, gear, speed, up_th, dn_th), rob_optim = Autotransc.autotransd 100. tstep (throttle, brake)
    and outp = Array.of_list [rpm; gear; speed; up_th; dn_th]
    and rob_spec = at53 (tstep', outp)
    and rob = if isFalse rob_spec then rob_spec else if isTrue rob_optim then rob_optim else rob_spec

node autotrans_at54 tstep inp = next_t, outp, rob where
    rec throttle = Array.get inp 0
    and brake = Array.get inp 1
    and init tstep' = make tstep
    and next_t = t +. tstep
    and (t, rpm, gear, speed, up_th, dn_th), rob_optim = Autotransc.autotransd 100. tstep (throttle, brake)
    and outp = Array.of_list [rpm; gear; speed; up_th; dn_th]
    and rob_spec = at54 (tstep', outp)
    and rob = if isFalse rob_spec then rob_spec else if isTrue rob_optim then rob_optim else rob_spec

node autotrans_at6a tstep inp = next_t, outp, rob + (make 0.1) where
    rec throttle = Array.get inp 0
    and brake = Array.get inp 1
    and init tstep' = make tstep
    and next_t = t +. tstep
    and (t, rpm, gear, speed, up_th, dn_th), _ = Autotransc.autotransd 100. tstep (throttle, brake)
    and outp = Array.of_list [rpm; gear; speed; up_th; dn_th]
    and rob = at6a (tstep', outp)

node autotrans_at6b tstep inp = next_t, outp, rob where
    rec throttle = Array.get inp 0
    and brake = Array.get inp 1
    and init tstep' = make tstep
    and next_t = t +. tstep
    and (t, rpm, gear, speed, up_th, dn_th), _ = Autotransc.autotransd 100. tstep (throttle, brake)
    and outp = Array.of_list [rpm; gear; speed; up_th; dn_th]
    and rob = at6b (tstep', outp)

node autotrans_at6c tstep inp = next_t, outp, rob where
    rec throttle = Array.get inp 0
    and brake = Array.get inp 1
    and init tstep' = make tstep
    and next_t = t +. tstep
    and (t, rpm, gear, speed, up_th, dn_th), _ = Autotransc.autotransd 100. tstep (throttle, brake)
    and outp = Array.of_list [rpm; gear; speed; up_th; dn_th]
    and rob = at6c (tstep', outp)
