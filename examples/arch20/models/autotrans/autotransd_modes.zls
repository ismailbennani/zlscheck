(*
  This example is adapted from a Simulink model:
  https://fr.mathworks.com/help/simulink/examples/modeling-an-automatic-transmission-controller.html

  This is a discrete implementation of the automatic transmission controller.

  Refer to the diff_plots folder to see comparisons between the continuous
  and the discrete versions of this model.
*)

open MyOp

(** consts **)

let zero_val = make 0.

let gear1 = make 1.
let gear2 = make 2.
let gear3 = make 3.
let gear4 = make 4.


(** utils **)

let string_of_op_t v = string_of_float (get v)

let node integrate_and_saturate(t, dx, x0, xmin, xmax) = x where
  rec timestep = t -> (t - pre t)
  and aux = x0 -> (pre aux + dx * timestep)
  and x = max xmin (min xmax aux)

(** algorithm **)

let node engine(t, ti, throttle) = rpm where
  rec te = Common_myop.lookup_engine(throttle, pre rpm)
  and drpm = te - ti
  and timestep = t -> (t - pre t)
  (* and _ = *)
    (* (print_endline ("pre Throttle: " ^ (string_of_op_t (pre throttle)));
     print_endline ("pre RPM     : " ^ (string_of_op_t (pre rpm))); *)
     (* print_endline ("pre te      : " ^ (string_of_op_t (pre te))); *)
     (* print_newline ();
     print_endline ("Throttle    : " ^ (string_of_op_t throttle));
     print_endline ("RPM         : " ^ (string_of_op_t rpm));
     print_endline ("dRPM/dt     : " ^ (string_of_op_t drpm));
     print_endline ("te          : " ^ (string_of_op_t te));
     print_endline ("ti          : " ^ (string_of_op_t ti));
     print_endline ("tstep       : " ^ (string_of_op_t timestep));
     print_newline (); print_newline ()) *)
  (* and rpm_aux = 0. -> (pre rpm +. Common_myop.engine_feedback_gain *. drpm *. timestep)
  and rpm = if rpm_aux > 6000. then 6000. else if rpm_aux < 600. then 600. else rpm_aux *)
  and rpm = integrate_and_saturate (t, scale drpm Common_myop.engine_feedback_gain, make 1000., make 600., make 6000.)

let node gearlogic(shift) = gear where
  rec init gear = gear1
  and automaton
      | First  ->
          do
          until shift(Common_myop.UP)
            then do next gear = gear2 in Second
      | Second ->
          do
          until shift(Common_myop.DOWN)
            then do next gear = gear1 in First
          else  shift(Common_myop.UP)
            then do next gear = gear3 in Third
      | Third  ->
          do
          until shift(Common_myop.DOWN)
            then do next gear = gear2 in Second
          else  shift(Common_myop.UP)
            then do next gear = gear4 in Fourth
      | Fourth ->
          do
          until shift(Common_myop.DOWN)
            then do next gear = gear3 in Third

let node shiftlogic(t, speed, throttle) = gear, rob where
  rec up_th = Common_myop.lookup_interpup(throttle, gear)
  and dn_th = Common_myop.lookup_interpdn(throttle, gear)

  and gear = gearlogic(shift)

  and automaton
      | SteadyState  ->
          let init go_up = make (Random.float 1.) > make 0.5 in
          (* let init tmp = print_endline (if go_up then "Aiming up!" else "Aiming down!") in *)
          do rob = if go_up then up_th - speed else speed - dn_th
          until (speed < dn_th)
            then
            (* do _ = print_endline "Shifting down!" in  *)
            DownShifting(t)
          else (speed > up_th)
            then
            (* do _ = print_endline "Shifting up!" in  *)
            UpShifting(t)
      | DownShifting(t0) ->
          do rob = zero_val
          until (speed > dn_th)
            then
            (* do _ = print_endline "abort" in  *)
            SteadyState
          else (t > translate t0 Common_myop.twait)
            then do emit shift = Common_myop.DOWN
            (* and _ = print_endline "DOWN!"  *)
            in SteadyState
      | UpShifting(t0)   ->
          do rob = zero_val
          until (speed < up_th)
            then
            (* do _ = print_endline "abort" in  *)
            SteadyState
          else (t > translate t0 Common_myop.twait)
            then do emit shift = Common_myop.UP
            (* and _ = print_endline "UP!"  *)
            in SteadyState

let node vehicle(t, out_torque, brake_torque) = (speed, trans_rpm) where
  rec timestep = t -> (t - pre t)
  and final_drive_ratio = scale out_torque Common_myop.p_final_drive_ratio
  and aux1 = final_drive_ratio - (pre signed_load)
  and vehicle_inertia = scale aux1 Common_myop.iv_inv
  and wheel_speed = make Common_myop.p_initial_wheel_speed ->
    (pre wheel_speed + vehicle_inertia * timestep)
  and linear_speed = scale wheel_speed Common_myop.l_speed_coef
  and mph = scale linear_speed Common_myop.p_mph
  and road_load = translate (scale (sqr mph) Common_myop.p_aerodynamic_drag) Common_myop.p_drag_friction
  and sgn = if mph >= zero_val then make 1. else make (-1.)
  and brake = brake_torque + road_load
  and signed_load = sgn * brake

  and trans_rpm = scale wheel_speed Common_myop.p_final_drive_ratio
  and speed = mph

open Scope

let node autotrans(t, (throttle, brake_torque)) = (rpm, gear, speed), rob where
  rec rpm = engine(t, ti, throttle)
  and gear, rob = shiftlogic(t, speed, throttle)
  and ti, out_torque = Common_myop.transmission(pre rpm, gear, pre trans_rpm)
  and speed, trans_rpm = vehicle(t, out_torque, brake_torque)

open Discrete_obs_fad

(* AT2:  â–¡_[0.0, 10.0] (RPM < 4750.0) *)
node phi ((tstep, (throttle, brake), (rpm, gear, speed)) :
            float * (MyOp.t * MyOp.t) * (MyOp.t * MyOp.t * MyOp.t)) =
    always_timed 10. (make tstep, q_lt (rpm, make 4750.))

let node main () =
  let tstep = 0.01 in
  let rec t = 0. fby t +. tstep in
  let rec automaton
  | I ->
      let rec local_t = 0. fby local_t +. tstep in
      (* do init th = make (Random.float 100.)
      and init br = make (Random.float 350.) *)
      do init th = make 100.
      and init br = make 0.
      until (make local_t >= make 5.) then I in

  let (rpm, gear, speed), mode_rob = autotrans (make t, (th, br)) in

  let rob = phi (tstep, (th, br), (rpm, gear, speed)) in
  let rec falsified = (rob < make 0.) -> (pre falsified || rob < make 0.) in

  let s1 = scope2(0., 350., ("throttle", linear, get th),
                            ("brake", linear, get br)) in
  let s2 = scope (0., 5000., ("rpm", linear, get rpm)) in
  let s3 = scope (0., 4., ("gear", linear, get gear)) in
  let s4 = scope (0., 130., ("speed", linear, get speed)) in
  let s5 = scope4(-120., 120., ("rob", linear, get rob),
                               ("fals?", linear, if falsified then 120. else -120.),
                               ("mode_rob", linear, get mode_rob),
                               ("", linear, 0.)) in

  windown("Autotrans", 30., t, [s1; s2; s3; s4; s5])
