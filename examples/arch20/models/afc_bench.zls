open MyOp
open Discrete_obs_fad

(* always_[11, 50] ((rise or fall) ==> (always_[1,5] (abs(mu) < 0.008))) *)
node afc1 (tstep, inp, outp) =
    let rec throttle = Array.get inp 0 in
    let mu = Array.get outp 2 in
    let throttle_40 = q_ge (throttle, make 40.) in
    let throttle_8_8 = q_le (throttle, make 8.8) in
    let abs_mu_0_008 = q_le (abs mu, make 0.008) in
    let rise = q_false -> q_and (throttle_40, pre throttle_8_8) in
    let fall = q_false -> q_and (throttle_8_8, pre throttle_40) in
    let rise_or_fall = q_or (rise, fall) in
    reset
        let rec t = make 0. fby (t + tstep) in
        always_timed 5. (tstep, implies (rise_or_fall,
            implies (q_ge (t, make 1.), abs_mu_0_008)))
    every (isTrue rise_or_fall)

(* always_[11, 50] abs(mu) < 0.007 *)
node afc2 (tstep, inp, outp) =
    let rec t = make 0. fby (t + tstep) in
    let mu = Array.get outp 2 in
    let abs_mu = abs mu in
    always_timed 50. (tstep, implies (q_ge (t, make 11.), q_lt (abs_mu, make 0.007)))

node afc_afc1 tstep inp = get next_t, outp, rob where
    rec throttle = Array.get inp 0
    and init engine = Array.get inp 1
    and tstep' = make tstep
    and next_t = tstep' fby (next_t + tstep')
    and t = make 0. fby next_t
    and abf, abf_ref, mu, mode = Afc_d.afc tstep (throttle, engine)
    and outp = Array.of_list [abf; abf_ref; mu; mode]
    and rob = afc1 (tstep', inp, outp)

node afc_afc2 tstep inp = get next_t, outp, rob where
    rec throttle = Array.get inp 0
    and init engine = Array.get inp 1
    and tstep' = make tstep
    and next_t = tstep' fby (next_t + tstep')
    and t = make 0. fby next_t
    and abf, abf_ref, mu, mode = Afc_d.afc tstep (throttle, engine)
    and outp = Array.of_list [abf; abf_ref; mu; mode]
    and rob = afc2 (tstep', inp, outp)
