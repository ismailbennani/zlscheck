open Constants
open F16_types
open Scope
open MyOp

(* for printing and drawing *)
let static tstep = 0.01

(* initial cond (paper):
    roll: [0.2pi, 0.2833pi] = [0.6283, 0.8900]
    pitch: [-0.5pi, -0.54pi] = [-1.5708, -1.6965]
    yaw: [0.25pi, 0.375pi] = [0.7854, 1.1781]
*)
(* initial cond (staliro):
    roll: [0.2pi, 0.2833pi] = [0.6283, 0.8901]
    pitch: [-0.4pi, -0.35pi] = [-1.2566, -1.0996]
    yaw: [-0.375pi, -0.125pi] = [-1.1781, -0.3927]
*)

let node print_state (t, s) =
    let init tmp =
        print_endline "t\tvt\talpha\tbeta\tphi\ttheta\tpsi\tp\tq\tr\tpn\tpe\th\tpow\tint-e-Nz\tint-e-ps\tint-e-Ny-r"
    in
    print_float (get t); print_string "\t";
    print_float (get s.f16.vt); print_string "\t";
    print_float (get s.f16.alpha); print_string "\t";
    print_float (get s.f16.beta); print_string "\t";
    print_float (get s.f16.phi); print_string "\t";
    print_float (get s.f16.theta); print_string "\t";
    print_float (get s.f16.psi); print_string "\t";
    print_float (get s.f16.p); print_string "\t";
    print_float (get s.f16.q); print_string "\t";
    print_float (get s.f16.r); print_string "\t";
    print_float (get s.f16.x9); print_string "\t";
    print_float (get s.f16.x10); print_string "\t";
    print_float (get s.f16.alt); print_string "\t";
    print_float (get s.f16.power); print_string "\t";
    print_float (get s.nz); print_string "\t";
    print_float (get s.ps); print_string "\t";
    print_float (get s.ny_r); print_string "\t";
    print_newline ()

let node run_model () =
    let initial_cond = {
        f16 = {
            vt = make 540.;
            alpha = scale dtor 2.1215; beta = make 0.;
            (* phi = 1.61686455757; theta = -0.347990119426; psi = -1.06805421104; *)
            phi = scale pi 0.25; theta = scale pi (-0.38); psi = scale pi (-0.3);
            p = make 0.; q = make 0.; r = make 0.;
            x9 = make 0.; x10 = make 0.;
            alt = make 4040.; power = make 9.;
        };
        nz = make 0.; ps = make 0.; ny_r = make 0.;
    } in
    let ctrlLimits = defaultCtrlLimits in

    let u, u_ref, state, state_der =
        Controlledf16.model (make tstep, initial_cond, ctrlLimits) in
    u, state, state_der

open Scope
let node main () =
    let t = F16_utils.integrate(make 0., make 1., make tstep) in
    let u, state, state_der = run_model () in

    let () = print_state (t, state) in

    (* let rec min_alt = state.f16.alt -> min (pre min_alt) state.f16.alt in
    print_string ("Minimum altitude : " ^ (string_of_float min_alt) ^ "\r");
    flush stdout; *)
    let s1 = scope (0., 15000., ("altitude", linear, (get state.f16.alt))) in
    let s2 = scopen(-90., 90., [
                    ("Roll phi (deg)", linear, (get (rtod * state.f16.phi)));
                    ("Roll rate (deg/s)", linear, (get (rtod * state.f16.p)));
                    ("Pitch theta (deg)", linear, (get (rtod * state.f16.theta)));
                    ("Pitch rate (deg/s)", linear, (get (rtod * state.f16.q)));
                    ("Yaw psi (deg)", linear, (get (rtod * state.f16.psi)));
                    ("Yaw rate (deg/s)", linear, (get (rtod * state.f16.r)))]) in
    let s3 = scope2(-30., 50.,
                    ("alpha (deg)", linear, (get (rtod * state.f16.alpha))),
                    ("beta (deg)", linear, (get (rtod * state.f16.beta)))) in
    let s4 = scope (0., 600.,
                    ("vt (ft/sec)", linear, (get state.f16.vt))) in
    window4("Controlled F16", 15., get t, s1, s2, s3, s4)
