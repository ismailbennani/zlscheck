open Constants
open Types

type state = Start | Roll | Pull | Done
let string_of_state state =
    match state with
    | Start -> "Start" | Roll -> "Roll" | Pull -> "Pull" | Done -> "Done"
    end

let node state_logic (tstep, alpha, phi, theta, p) =
    let t = Utils.integrate(0., 1., tstep) in

    let eps_phi = 5. *. dtor in
    let eps_p = 1. *. dtor in
    let path_goal = 0. *. dtor in
    let man_start = 2. in

    let automaton
    | Start ->
        do state = Start
        until (t > man_start &&
            (theta -. alpha) -. 2. *. pi *. Utils.round ((theta -. alpha) /. (2. *. pi)) > path_goal)
            then do emit trans = Done in Done
        else (t > man_start && abs_float p < eps_p &&
                (abs_float (phi -. pi *. (Utils.round (phi /. pi))) < eps_phi))
                then do emit trans = Pull in Pull
        else (t > man_start) then do emit trans = Roll in Roll
    | Roll ->
        let radsFromWingsLevel = Utils.round (phi /. pi) in
        let wings_are_level =
            abs_float (phi -. pi *. radsFromWingsLevel) < eps_phi
        and rate_is_small = abs_float p < eps_p
        in
        do state = Roll
        (* and present (period(0.1)) -> do
            () = print_endline ("at t = " ^ (string_of_float t) ^ ", STATE : Roll" ^
                    "\n\tphi = " ^ (string_of_float phi) ^
                    "\n\teps_phi = " ^ (string_of_float eps_phi) ^
                    "\n\tp = " ^ (string_of_float p) ^
                    "\n\teps_p = " ^ (string_of_float eps_p) ^
                    "\n\tradsFromWingsLevel = " ^ (string_of_float radsFromWingsLevel) ^ "\n"
                )
        done *)
        until (wings_are_level && rate_is_small)
        then do emit trans = Pull in Pull
    | Pull ->
        let radsFromNoseLevel = Utils.round ((theta -. alpha) /. (2. *. pi)) in
        do state = Pull
        (* and present (period(0.1)) -> do
            () = print_endline ("at t = " ^ (string_of_float t) ^ ", STATE : Pull" ^
                    "\n\ttheta = " ^ (string_of_float theta) ^
                    "\n\talpha = " ^ (string_of_float alpha) ^
                    "\n\ttheta - alpha = " ^ (string_of_float (theta -. alpha)) ^
                    "\n\tradsFromNoseLevel = " ^ (string_of_float radsFromNoseLevel)
                )
        done *)
        until (theta -. alpha -. 2. *. pi *. radsFromNoseLevel > path_goal)
        then do emit trans = Done in Done
    | Done -> do state = Done done
    in

    (* let present trans(new_state) -> do
        () = print_endline ("At t = " ^ (string_of_float t) ^
                    ", state switched from " ^ (string_of_state state) ^
                    " to " ^ (string_of_state new_state))
    done in *)

    state, (present trans(_) -> true else false)

let discrete get_u_ref (state, ctrlLimits, x_equil, x) = u_ref where rec

    match state with
    | Start -> do nz = 0. and ps = 0. done
    | Roll ->
        local radsFromWingsLevel, k_prop, k_der
        do
            radsFromWingsLevel = Utils.round (x.phi /. pi)
            and k_prop = 4.
            and k_der = k_prop *. 0.3
            and ps = -. (x.phi -. pi *. radsFromWingsLevel) *. k_prop -. x.p *. k_der
            and nz = 0.
        done
    | Pull ->
        do
            nz = min 5. ctrlLimits.Types.nzMax
            and ps = 0.
        done
    | Done ->
        local radsFromWingsLevel, radsFromNoseLevel,
              k_prop, k_der, k_prop2, k_der2
        do
            k_prop = 1.
            and k_der = k_prop *. 0.3
            and radsFromWingsLevel = Utils.round (x.phi /. pi)
            and ps = -. (x.phi -. pi *. radsFromWingsLevel) *. k_prop -. x.p *. k_der
            and k_prop2 = 2.
            and k_der2 = k_prop2 *. 0.3
            and radsFromNoseLevel = Utils.round ((x.theta -. x.alpha) /. pi)
            and nz = -. (x.theta -. x.alpha -. pi *. radsFromNoseLevel) *. k_prop2
                     -. x.p *. k_der2
        done

    and ny_r = 0.

    and k_vt = 0.25
    and throttle = -. k_vt *. (x.vt -. x_equil.vt)

    and u_ref = {
        thtlc_ref = throttle; nz_ref = nz; ps_ref = ps; ny_r_ref = ny_r
    }
